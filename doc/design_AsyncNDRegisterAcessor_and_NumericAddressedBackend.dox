namespace ChimeraTK {
/**
\page design_AsyncNDRegisterAccessor_NumericAddressed Design: AsyncNDRegisterAccessor


\section conceptOverview Concept overview

@warning This document is currently being rewritten!

\subsection design_AsyncAccessorManager AsyncNDRegisterAccessors and the AsyncAccessorManager
\dot
digraph aysnc_manager_var_relation {
  compound=true;
  node [shape=record, fontname=Helvetica, fontsize=10];
  rankdir=LR
  subgraph cluster_mgr{
   label="AsyncAccessorManager" URL="\ref AsyncAccessorManager";
   vars [ label="<var1>AsyncVariable|<var2>AsyncVariable|..." URL="\ref AsyncVariable"];
  }
  acc1 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor"];
  acc1 -> vars:var1  [ label="shared_ptr", lhead=cluster_mgr ];
  vars:var1 -> acc1 [ arrowhead="empty", style="dashed", label="weak_ptr" ];
  acc2 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor"];
  acc2 -> vars:var2 [ lhead=cluster_mgr ];
  vars:var2 -> acc2 [ arrowhead="empty", style="dashed" ];
}
\enddot

\subsection design_TriggeredPollDistributor The TriggeredPollDistributor

\dot
digraph triggered_poll_distributor {
  compound=true;
  node [shape=record, fontname=Helvetica, fontsize=10];
  rankdir=LR
  subgraph cluster_PollDistributor{
    label="TriggeredPollDistributor" URL="\ref TriggeredPollDistributor";
    TransferGroup
    NDRegisterAccessor [ label="NDRegisterAccessor" ]
    NDRegisterAccessor2 [ label="NDRegisterAccessor" ]
    vars [ label="<var1>PolledAsyncVariable|<var2>PolledAsyncVariable|..." URL="\ref AsyncVariable"];
  }
  acc1 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor"];
  vars:var1 ->  acc1 [ arrowhead="empty", style="dashed", label="weak_ptr" ];
  acc1 -> vars:var1 [ label="shared_ptr",  lhead=cluster_PollDistributor];

  acc2 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor"];
  acc2 -> vars:var2 [ lhead=cluster_PollDistributor ];
  vars:var2 ->  acc2 [ arrowhead="empty", style="dashed"];
  
  TransferGroup -> NDRegisterAccessor;
  TransferGroup -> NDRegisterAccessor2;

  NDRegisterAccessor-> vars:var1 [ arrowhead="none", arrowtail="normal", dir = "back"];
  NDRegisterAccessor2-> vars:var2 [ arrowhead="none", arrowtail="normal", dir = "back"];
  
  
}
\enddot

\subsection design_TriggerDistributor The TriggerDistributor

\dot
digraph reverse_ownership_scheme {
  compound=true;
  node [shape=record, fontname=Helvetica, fontsize=10];
  rankdir=LR
  
  Backend[color=blue, fontcolor=blue]
  TriggerDistributor[color=blue, fontcolor=blue]
  Backend -> TriggerDistributor[color=blue, fontcolor=blue]
  
  secondPrimaryDistributor[label ="TriggerDistributor", style="dotted", color=blue, fontcolor=blue]
  Backend -> secondPrimaryDistributor[color=blue, fontcolor=blue]
  thirdPrimaryDistributor[label ="TriggerDistributor", style="dotted", color=blue, fontcolor=blue]
  Backend -> thirdPrimaryDistributor[color=blue, fontcolor=blue]

  subgraph cluster_distributor1{
   label="VariableDistributor<Void>" URL="\ref VariableDistributor";
   distrVars1 [ label="<distrVar1>VoidAsyncVariable|<distrVar2>VoidAsyncVariable|..."];
  }

  TriggerDistributor->distrVars1 [ lhead=cluster_distributor1, arrowhead="empty", style="dashed"  ];
  distrVars1->TriggerDistributor [ ltail=cluster_distributor1, label=" "];

  distr1Acc1 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  distr1Acc1 ->  distrVars1:distrVar1  [ lhead=cluster_distributor1 ];
  distrVars1:distrVar1 -> distr1Acc1 [ arrowhead="empty", style="dashed"];
  distr1Acc2 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  distr1Acc2 ->  distrVars1:distrVar2  [ lhead=cluster_distributor1 ];
  distrVars1:distrVar2 -> distr1Acc2 [ arrowhead="empty", style="dashed"];

  subgraph cluster_PollDistributor{
    label="TriggeredPollDistributor" URL="\ref TriggeredPollDistributor";
    TransferGroup
    NDRegisterAccessor [ label="NDRegisterAccessor", color=red, fontcolor=red ]
    NDRegisterAccessor2 [ label="NDRegisterAccessor", color=red, fontcolor=red  ]
    vars [ label="<var1>PolledAsyncVariable|<var2>PolledAsyncVariable|..." URL="\ref AsyncVariable"];
  }
  acc1 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  vars:var1 ->  acc1 [ arrowhead="empty", style="dashed", label="weak_ptr" ];
  acc1 -> vars:var1 [ label="shared_ptr",  lhead=cluster_PollDistributor];

  acc2 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  acc2 -> vars:var2 [ lhead=cluster_PollDistributor ];
  vars:var2 ->  acc2 [ arrowhead="empty", style="dashed"];
  
  TransferGroup -> NDRegisterAccessor;
  TransferGroup -> NDRegisterAccessor2;

  NDRegisterAccessor-> vars:var1 [ arrowhead="none", arrowtail="normal", dir = "back"];
  NDRegisterAccessor2-> vars:var2 [ arrowhead="none", arrowtail="normal", dir = "back"];

  TriggerDistributor->TransferGroup  [ lhead=cluster_PollDistributor, arrowhead="empty", style="dashed"  ];
  TransferGroup->TriggerDistributor [ ltail=cluster_PollDistributor, label=" " ];

  subgraph cluster_interruptCtrlHdl1{
    label="InterruptControllerHandler" URL="\ref InterruptControllerHandler";
    hdlAccs1 [ label="<hdlAcc1>NDRegisterAccessor|<hdlAcc2>NDRegisterAccessor|...", color=red, fontcolor=red ];
  }
  TriggerDistributor->hdlAccs1 [ lhead=cluster_interruptCtrlHdl1, arrowhead="empty", style="dashed"  ];
  hdlAccs1->TriggerDistributor [ ltail=cluster_interruptCtrlHdl1, label=" " ];

  TriggerDistributor2 [label = TriggerDistributor]
  hdlAccs1->TriggerDistributor2 [ ltail=cluster_interruptCtrlHdl1, arrowhead="empty", style="dashed"  ];
  TriggerDistributor2->hdlAccs1 [ lhead=cluster_interruptCtrlHdl1, label=" " ];

  subgraph cluster_PollDistributor2{
    label="TriggeredPollDistributor" URL="\ref TriggeredPollDistributor";
    TransferGroup2 [ label="TransferGroup" ]
    NDRegisterAccessor3 [ label="NDRegisterAccessor" , color=red, fontcolor=red ]
    NDRegisterAccessor4 [ label="NDRegisterAccessor" , color=red, fontcolor=red ]
    polledVars2 [ label="<polledVar3>PolledAsyncVariable|<polledVar4>PolledAsyncVariable|..."];
  }
  polledAcc3 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  polledVars2:polledVar3 ->  polledAcc3 [ arrowhead="empty", style="dashed"];
  polledAcc3 -> polledVars2:polledVar3 [ label=" ", lhead=cluster_PollDistributor2];

  polledAcc4 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  polledVars2:polledVar4 ->  polledAcc4 [arrowhead="empty", style="dashed" ];
  polledAcc4 -> polledVars2:polledVar4 [ label=" ", lhead=cluster_PollDistributor2];
  
  TransferGroup2 -> NDRegisterAccessor3
  TransferGroup2 -> NDRegisterAccessor4;

  NDRegisterAccessor3->  polledVars2:polledVar3 [ arrowhead="none", arrowtail="normal", dir = "back"];
  NDRegisterAccessor4->  polledVars2:polledVar4  [ arrowhead="none", arrowtail="normal", dir = "back"];

  TriggerDistributor2->TransferGroup2  [ lhead=cluster_PollDistributor2, arrowhead="empty", style="dashed"  ];
  TransferGroup2->TriggerDistributor2 [ ltail=cluster_PollDistributor2, label=" " ];

  subgraph cluster_distributor2{
   label="VariableDistributor<Void>" URL="\ref VariableDistributor";
   distrVars2 [ label="<distrVar3>VoidAsyncVariable|<distrVar4>VoidAsyncVariable|..."];
  }

  TriggerDistributor2->distrVars2 [ lhead=cluster_distributor2, arrowhead="empty", style="dashed"  ];
  distrVars2->TriggerDistributor2 [ ltail=cluster_distributor2, label=" "];

  distr2Acc3 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  distr2Acc3 ->  distrVars2:distrVar3  [ lhead=cluster_distributor2 ];
  distrVars2:distrVar3 -> distr2Acc3 [ arrowhead="empty", style="dashed"];
  distr2Acc4 [ label="AsyncNDRegisterAccessor" URL="\ref AsyncNDRegisterAccessor", color=green, fontcolor=green];
  distr2Acc4 ->  distrVars2:distrVar4  [ lhead=cluster_distributor2 ];
  distrVars2:distrVar4 -> distr2Acc4 [ arrowhead="empty", style="dashed"];

  interruptCtrlHdl2 [label="InterruptControllerHandler\n...", style="dotted"]
  
  TriggerDistributor2->interruptCtrlHdl2 [ arrowhead="empty", style="dashed"]
  interruptCtrlHdl2->TriggerDistributor2
}
\enddot

- Access is from left to right (trigger/data distribution), mostly through weak pointers (dashed lines and empty arrow head)
- Fixed ownership when starting the backend: Primary TriggerDistributors (blue)
- InterruptControllerHandlers and TriggeredPollDistributors are holding accessors to the backend to read data or do handshakes (red), which in turn are holding shared pointers to the backend (shared ownership). The backend must never (also not indirectly) hold a shared pointer to any of these entities because it would introduce a closed ownership circle and the backend could never be deleted properly.
- Ownership via solid line arrow, mostly from left to right. In the end the AsyncNDRegisterAccessors handed out to the user (green) are are holding the whole infrastructure
  (except for primary TriggerDistributors in blue)
- When an accessor is requested, the request goes to the primary TriggerDistributor, which creates all required InterruptControllerHandlers, TriggerDistributors, VariableDistributors
  or TriggeredPollDistributors when needed, and hands out the AsyncNDRegisterAccessor which holds the ownership. It shares the ownership with other AsyncNDRegisterAccessors.
- When the last owning AsyncNDRegisterAccessors goes out of scope, the according distributors are deleted.
- If there are no subscribers, i.e. AsyncNDRegisterAccessors being held by the application, the primary TriggerDistributors are empty and do nothing.

#########################################################################################################################################
# Old text below. Cross-read before deleting to check if something relevant has been missed!
#########################################################################################################################################


- For each AsyncAccessor that user requests: an AsyncVariable is created interally, with 1:1 correspondence
  AsyncAccessor ↔ AsyncVar
- AsyncAccessor reads from AsyncVar and is handed out to user; AsyncVariable holds the send buffer which is used to
  fill userBuffer of AsyncAccessor later
- NumericAddressedAsyncVarImpl implements filling the send buffer from a syncAccessor to the requested register
- NumericAddressedInterruptDispatcher is responsible for one interrupt number and collects related SyncAccessors
  in a transferGroup for efficiency. It implements the actual trigger action (on interrupt), relying on NumericAddressedAsyncVarImpl::filledSendBuffer().
- AsyncVarImpl holds only a weak pointer to the AsyncAccessor, since we want to be sensitive to the user discarding
  the latter
- NumericAddressedInterruptDispatcher, as a AsyncAccessorManager, owns and manages the AsyncVariables (in a map).
- Actual copy operations are eliminated by usage of swap, i.e. only pointers are handed over between the buffer containers.
- Exception handling: If any exception occurs during read/write, AsyncAccessorManager deactivates the AsyncVariables
  and provides each of them the exception. When activated again, it makes sure new or initial values from the SyncAccessors are provided.
- Deletion: once user releases shared pointer to AsyncNDRegAcc, its destructor calls AsyncAccessorManager::unsubscribe().
  Since the syncAccessors in the TransferGroup keep a shared pointer to the NumericAddressBackend, unsubscribe() must also take care to clean up TransferGroup.


\section  design_AsyncNDRegisterAccessor The AsyncNDRegisterAccessor and the AsyncAccessorManager

The AsyncNDRegisterAccessor is a generic NDRegisterAccessor implementation for push-type data. It is used
if accessors with AccessMode::wait_for_new_data are requested. See \ref transferElement_B_8
"Technical specification: TransferElement B.8" for the requirements it is based on.

The AsyncNDRegisterAccessor is a generic implementation which can be used for all backends and contains the following
components

- a lock free queue to transport data of type NDRegisterAccessor<UserType>::Buffer, which contains the data value
  (2D vector of UserType), a VersionNumber and a DataValidity flag.
- functions to activate/deactivate the accessor, and to push data and exceptions into the queue
- a (synchronous) accessor which is used for write operations (optional)

A *trigger domain* is a set of registers for which the data is always send together. Examples:

- For the pcie backend, a set of registers described in the map file is read from the device  and the data is pushed
  into the according AsyncNDRegisterAccessessors when the according interrupt occurs.
- For push-type data with a composed data type, DeviceAccess provides individual registers for the components which
  make up a trigger domain
  (e.g. for a DOOCS IFFF there is one int and three floats in the trigger domain).
- A trigger domain can consist of a single register.
 
One AsyncAccessorManager is used per trigger domain. The AsyncAccessorManager has three main functions:

- It serves as a factory for AsyncNDRegisterAccessors
- It contains a list of created asynchronous accessors and a subscribe/unsubscribe mechanism
- It provides functions to act on all asynchronous accessors

\subsection AsyncNDRegisterAccessor_details Design decisions and implementation details

- The data transport queue contains data that is already converted to the UserType, so the potentially expensive and
  slow operations (data readout,
  de-multiplexing, data conversion) are happening only once, before the data is distributed to multiple subscribers.
- To unsubscribe, the NDRegisterAccessor is calling AsyncAccessorManager::unsubscribe() with its TransferElementID from
  the destructor.
- The class AsyncVariable represents the sender side of the asynchronous accessor.\ref asyncAccessor_comment_AsyncVariable "(*)"
  It provides functions to send data and exceptions, to activate and to deactivate the accessors,  and it implements
  all the handling of the contained AsyncNDRegisterAccessor instance.
  In addition it provides shape information for creating AsyncNDRegisterAccessors to the AsyncAccessorManager.
- A send buffer is contained in the AsyncVariable to avoid dynamic memory allocation.
- The void notification queue in the TransferElement base class is set up as a continuation of the data transport queue,
  such that the read operations of the notification queue trigger the filling of the user buffer.

\anchor asyncAccessor_comment_AsyncVariable (*) C++ implementation detail:
  There is AsyncVariable as an untyped base class and AsyncVariableImpl,
  which is templated to a user type. Like this pointers to variables with different user types can be stored in one list.

\subsection AsyncNDRegisterAccessor_usage Interface for implementing backends

While the AsyncNDRegisterAccessor itself is complete and universal, the AsyncAccessorManager and
AsyncVariable have pure virtual functions which must be provided by the individual
backend implementations:
- AsyncVariable::getNumberOfChannels(), AsyncVariable::getNumberOfSamples(), AsyncVariable::getUnit(),
  AsyncVariable::getDescription() and AsyncVariable::isWriteable() must be provided by deriving from AsyncVariable or
  AsyncVariableImpl. The information must directly be provided by the backend.
  The generating code cannot rely on the catalogue here (which might not even be filled yet when the accessor
  is being created).\ref asyncAccessor_comment_AsyncVariable2 "(*2)"
- The 'virtual function template' AsyncAccessorManager::createAsyncVariable() must return an AsyncVariable
  implementation with the implemented accessor-describing functions from the previous bullet point.
  When the AsyncVariable object is returned by createAsyncVariable(), its weak pointer to the AsyncNDRegisterAccessor
  is not set yet.
  createAsyncVariable() is used internally by the AsyncAccessorManager in the subscription process,
  which creates the AsyncNDRegisterAccessor by using the shape information from the AsyncVariable,
  and then adds it to the AsyncVariable.
- AsyncAccessorManager::activate() needs to be implemented in the following way\ref asyncAccessor_comment_activate "(*3)":
  -# Lock the _variablesMutex which protects the container of AsyncVariables, so no entries can be added or removed
     \ref asyncAccessor_comment_mutex "(*4)"
  -# Generate a new version number while holding the lock
  -# Write the initial value, the according data validity flag and the version number to the _sendBuffer of each
     AsyncVariable
  -# Call activate() on all AsyncVariables
  - 3. and 4. can also be implemented together by looping all variables once, i.e. preparing the _sendBuffer and
    activating one variable before continuing with the next one.

The backend uses the AsyncNDRegisterAccessor by
- creating one AsyncAccessorManager for each trigger domain
- calling AsyncAccessorManager::subscribe() in getRegisterAccessor(), and handing out the created AsyncNDRegisterAccessor.
  If the accessor is writeable (according to the AsyncVariable), the AsyncAccessorManager will call
  getRegisterAccessor() recursively without the wait_for_new_data flag for the same register, and add
  this accessor as write accessor to the AsyncNDRegisterAccessor. The backend's getRegisterAccessor() implementation
  must be able to handle this recursive call.\ref asyncAccessor_comment_writeable "(*5)"
- calling AsyncAccessorManager::activate() in activateAsyncRead()
- calling AsyncAccessorManager::sendException() in setException()
- calling AsyncAccessorManager::deactivate() when the backend is closed.

The code sending the data has to follow a similar sequence as AsyncAccessorManager::activate():
-# Lock the _variablesMutex which protects the container of AsyncVariables, so no entries can be added or removed
-# Generate a new version number while holding the lock. All accessors of the same trigger domain must
   have the same version number for the same trigger.
-# Prepare the _sendBuffer, incl. data validity flag and version number for each AsyncVariable
-# Call send() on all AsyncVariables
- 3. and 4. can also be implemented together by looping all variables once, i.e. preparing the _sendBuffer and
  calling send() for one variable before continuing with the next one.

\anchor asyncAccessor_comment_AsyncVariable2 (*2) The reason to put this into the AsyncVariable is coming from the
  NumericAddressedBackend. It adds a synchronous accessor to the AsyncVariable which is used for reading and
  provides this information. The logic to generate this information is in the creation code for the synchronous
  accessor. Other backends might have similar advantages from having the functions the AsyncVariable, or at least
  they don't care much where the functions are implemented.

\anchor asyncAccessor_comment_activate (*3)  Locking of the mutex, generating the version number and calling activate()
  on each variable could be factored into
  the manager, with additional virtual functions that are called in between, but this means the container needs to be
  looped several times and the design gets more complicated and involved,
  and hence the implementation is left to the backend.

\anchor asyncAccessor_comment_mutex (*4) Holding the mutex while accessing the AsyncVariables actually serves two
purposes:
-# It prevents the container from being modified and variables going out of scope while being accessed.
-# The AsyncVariables and the AsyncNDRegisterAcessors in them are not thread safe, and activation/deactivation,
   exception sending and data sending are coming from different threads.

\anchor asyncAccessor_comment_writeable (*5) Even if the implementation already has a synchronous read accessor,
like the NumericAccdressedBackend, this cannot be used for writing. The write is coming from a user thread,
while the read is coming from a thread receiving data though the transfer protocol.

\section  design_async_NumericAddressedBackend Implementation in the NumericAddressedBackend

\subsection design_async_map_file Asynchronous registers in the map file

<pre>
# name            nElements  address  nBytes  bar  width  bitInterpretation signed accessMode
APP.0.DATA_READY          0        0       0    0      0                  0      0 INTERRUPT1
APP.0.PUSH_DATA           4       12      16    1     32                  8      1 INTERRUPT2
</pre>

The map file has a special access mode INTERRUPTx, in addition to the synchronous modes RW and RO.
x is the numeric identifyer for a device interrupt. Registers with access mode INTERRUPT are treated as read-only.
Nested interrupts (INTERRUPTx:y, INTERRUPTx:y:z, etc.) are supported in combination with InterruptControllerHandlers (see below).

For interrupts it is possible to have void-type entries. The width of these "registers" is 0 bits. For consistency all other fields also have to be 0. They don't make sense in this context and have to be 0 to avoid confusion.

For each interrupt and nesting level it is possible to get a void accessor via the canonical interrupt name '!x:y:z:'. For instance for a nested interrupt with data on INTERRUPT3:9:4, it is possible to get void accessors for '!3', '!3:9' and '!3:9:4'. This is useful to check whether a primary interrupt has arrived, or any interrupt on the nested controller 3:9.

\subsection design_interrupt_constroller_handlers InterruptControllerHandlers

\subsection implementation_async_NumericAddressed Design and implementation details

The NumericAddressedBackend has a complete implementation 0
of the AsyncAccessorManager and the AsyncVariable, called
NumericAddressedInterruptDispatcher and NumericAddressedAsyncVariable, respectively.

- Each NumericAddressedAsyncVariable has a synchronous accessor for reading the data from the device when an
  interrupt arrives.
- Each NumericAddressedInterruptDispatcher has a transfer group with all the synchronous read accessors,
  so the data transfer is
  optimised under the hood (data is only transferred once, transfers are merged, copy decorators are used where
  necessary so de-multiplexing and conversion is only happening once, and the converted data is duplicated).
- There is one NumericAddressedInterruptDispatcher per interrupt that is described in the map file.
  They are created when the map file is being processed.
- The accessor manager has been extended by a trigger() function, which reads the transfer groups and dispatches the read
  results to all subscribed asynchronous accessors.

\subsection  async_NumericAddressedBackend_interface Interface to implementing backends

The list of primary TriggerDistributors is private, and all implementing backends interface with it through two functions.

- NumericAddressedBackend::startInterruptHandlingThread(unsigned int interruptControllerNumber, unsigned int
  primaryInterruptNumber) is a virtual function which is called each time an accessor for that primary interrupt is requested.
  This allows the lazy start of the interrupt handling threads, which are not started if no accessors are requested.
  The implementation must assure that the thread is only started once. In general, the NumericAddressedBackend does
  not take care of interrupt handling threads, except for calling this virtual function. Each backend implementation
  has to take care that treads are started, terminated and joined correctly.
  There is an empty default implementation of startInterruptHandlingThread() for backward compatibility
  (backends that don't support asynchronous data (yet) or that don't need a separate thread like the dummies).
- The interrupt handling threads call NumericAddressedBackend::dispatchInterrupt(unsigned int interruptControllerNumber,
  unsigned int  primaryInterruptNumber) each time the according interrupt arrives.
  
All other functionality for subscription, activation/deactivation and exception handling is already handled in the
NumericAddressedBackend base class.


*/

} // end of namespace ChimeraTK
