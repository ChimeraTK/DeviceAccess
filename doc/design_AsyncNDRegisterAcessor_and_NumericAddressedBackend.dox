namespace ChimeraTK {
/**
\page design_AsyncNDRegisterAccessor_NumericAddressed Design: AsyncNDRegisterAccessor

\section  design_AsyncNDRegisterAccessor The AsyncNDRegisterAccessor and the AsyncAccessorManager

The AsyncNDRegisterAccessor is the NDRegisterAccessor implementation for push-type data. It is used
if accessors with AccessMode::wait_for_new_data are requested. See \ref transferElement_B_8
"Technical specification: TransferElement B.8" for the requirements it is based on.

The AsyncNDRegisterAccessor is a generic implementation for all backends and contains the following components

- an NDRegisterAccessor<UserType>::Buffer which serves as a send buffer and contains the data value
  (2D vector of UserType), a VersionNumber and a DataValidity flag.
- a lock free queue to transport the data of the send buffer
- functions to activate/deactivate the accessor, and to push data and exceptions into the queue
- a (synchronous) accessor which is used for write operations (optional)

One AsyncAccessorManager is used per interrupt that can occur. The AsyncAccessorManager has three main functions:

- It serves as a factory for AsyncNDRegisterAccessors
- It contains a list of created asynchronous accessors and a subscribe/unsubscribe mechanism
- It provides functions to act on all asynchronous accessors

\subsection AsyncNDRegisterAccessor_details Design decisions and implementation details

- The data transport queue is of type UserType, so the potentially expensive and slow operations (data readout,
  de-multiplexing, data conversion) are happening only once, before the data is distributed to multiple subscribers.
- The additional send buffer is necessary because data has to be send through the queue in this container, and usually
  the data is not provided in this format.
  Even if the NDRegisterAccessor would provide the user buffer in this format it could not be used here, because it is
  used by the receiving side which is running in another thread.
- To unsubscribe, the NDRegisterAccessor is calling AsyncAccessorManager::unsibscribe() with its TransferElementID from
  the destructor.
  For the unsubscribe mechanism to work, the AsyncAccessorManager can only hold a weak pointer.
  If it would hold a shared pointer, the destructor would never be called because this instance survives,
  even if the user code has deleted all copies of the AsyncNDRegisterAccessor.
- To manage the weak pointer and to have an entry object for the implementation, the helper class
  AsyncVariable has been introduced.\ref asyncAccessor_comment_AsyncVariable "(*)"
  It contains the weak pointer as a private variable and provides member functions to access the object behind
  the weak pointer.
  This ensures two points which otherwise would be left to the implementation, which would be error prone:
  - The weak pointer is locked before accessing the object.
  - There is a race condition that the locked object could have a nullptr if the shared pointer is currently being
     destructed while the lock is being acquired. This is checked as well.
- The void notification queue in the TransferElement base class is set up as a continuation of the data transport queue,
  such that the read operations of the notification queue trigger the filling of the user buffer.

\anchor asyncAccessor_comment_AsyncVariable (*) There is AsyncVariable as an untyped base class and AsyncVariableImpl,
  which is templated to a user type. Like this pointers to variables with different user types can be stored in one list.

\subsection AsyncNDRegisterAccessor_usage Interface for implementing backends

While the AsyncNDRegisterAccessor itself is complete and universal, the AsyncAccessorManager and
AsyncVariable have pure virtual functions which must be provided by the individual
backend implementations:
- AsyncVariable::getNumberOfChannels(), AsyncVariable::getNumberOfSamples(), AsyncVariable::getUnit(),
  AsyncVariable::getDescription() and AsyncVariable::isWriteable() must be provided by deriving from AsyncVariable or
  AsyncVariableImpl. The information must directly be provided by the backend.
  The generating code cannot rely on the catalogue here (which might not even be filled yet when the accessor
  is being created).\ref asyncAccessor_comment_AsyncVariable "(*2)"
- The 'virtual function template' AsyncAccessorManager::createAsyncVariable() must return an AsyncVariable
  implementation with the implemented accessor-describing functions from the previous bullet point, such that the
  accessor manager can create the AsyncNDRegisterAccessor.
  When createAsyncVariable() returns the AsyncVariable object, the weak pointer to the AsyncNDRegisterAccessor is not
  set yet. The reason is that the backend specific code should not have the subscription code, which is the same for
  all backends and would only be code duplication. And it is not sufficient to have the AsyncVariable, which only
  contains the weak pointer. The calling code also needs the shared pointer to the AsyncNDRegisterAccessor.
  createAsyncVariable() is used internally by the AsyncAccessorManager, which creates the AsyncNDRegisterAccessor
  and adds it to the AsyncVariable in the subscription process.
- AsyncAccessorManager::activate() needs to be implemented in the following way:
  -# Lock the mutex which protects the list of weak pointer, so no entries can be added or removed
  -# Generate a new version  number while holding the lock
  -# Write the initial value, the according data validity flag and the version number to the _sendBuffer of each
     AsyncVariable
  -# Call activate() on all AsyncVariables
  
  Locking of the mutex, generating the version number and calling activate() on each variable could be factored into
  the manager, with additional virtual functions that are called in between, but this means the container needs to be
  looped several times and the design gets more complicated and involved,
  and hence the implementation is left to the backend.

The backend uses the AsyncNDRegisterAccessor by
- creating one AsyncAccessorManager for each interrupt that can occur (or for each push type variable that is being
  subscribed from a sender)
- calling AsyncAccessorManager.subscribe() in getRegisterAccessor(), and handing out the created AsyncNDRegisterAccessor.
  If the accessor is writeable (according to the AsyncVariable), the AsyncAccessorManager will call
  getRegisterAccessor() recursively without the wait_for_new_data flag for the same register, and add
  this accessor as write accessor to the AsyncNDRegisterAccessor. The backend's getRegisterAccessor() implementation
  must be able to handle this recursive call.\ref asyncAccessor_comment_writeable "(*3)"
- calling AsyncAccessorManager::activate() in activateAsyncRead()
- calling AsyncAccessorManager::sendException() in setException()
- calling AsyncAccessorManager::deactivate() when the backend is closed.

\anchor asyncAccessor_comment_AsyncVariable (*2) The reason to put this into the AsyncVariable is coming from the
  NumericAddressedBackend. It adds a synchronous accessor to the AsyncVariable which is used for reading and
  provides this information. The logic to generate this information is in the creation code for the synchronous
  accessor. Other backends might have similar advantages from having the functions the AsyncVariable, or at least
  they don't care much where the functions are implemented.

\anchor asyncAccessor_comment_writeable (*3) Even if the implementation already has a synchronous read accessor,
like the NumericAccdressedBackend, this cannot be used for writing. The write is coming from a user thread,
while the read is coming from the interrupt handler thread.

\section  design_async_NumericAddressedBackend Implementation in the NumericAddressedBackend

\subsection design_async_map_file Asynchronous registers in the map file

<pre>
# name            nElements  address  nBytes  bar  width  bitInterpretation signed accessMode
APP.0.DATA_READY          0        0       0    0      0                  0      0 INTERRUPT1:5
APP.0.PUSH_DATA           4       12      16    1     32                  8      1 INTERRUPT2:3
</pre>

The map file has been extended by the access mode INTERRUPTx:y. Before, only RW and RO were allowed. x and y are the
number of the interrupt controller and the interrupt number, respectively. Registers with access mode INTERRUPT will
implicitly be treated as read-only.

For interrupts it is possible to have void-type entries. The width of these "registers" is 0 bits. For consistency all other fields also have to be 0. They don't make sense in this context and have to be 0 to avoid confusion.

\subsection implementation_async_NumericAddressed Design and implementation details

The NumericAddressedBackend has a complete implementation of the AsyncAccessorManager and the AsyncVariable, called
NumericAddressedInterruptDispatcher and NumericAddressedAsyncVariable, respectively.

- Each NumericAddressedAsyncVariable has a synchronous accessor for reading the data from the device when an
  interrupt arrives.
- Each NumericAddressedInterruptDispatcher has a transfer group with all the synchronous read accessors,
  so the data transfer is
  optimised under the hood (data is only transferred once, transfers are merged, copy decorators are used where
  necessary so de-multiplexing and conversion is only happening once, and the converted data is duplicated).
- There is one NumericAddressedInterruptDispatcher per interrupt that is described in the map file.
  They are created when the map file is being processed.
- The accessor manager has been extended by a trigger() function, which reads the transfer groups and dispatches the read
  results to all subscribed asynchronous accessors.

\subsection  async_NumericAddressedBackend_interface Interface to implementing backends

The list of accessor managers is private, and all implementing backends interface with it through two functions.

- NumericAddressedBackend::startInterruptHandlingThread(unsigned int interruptControllerNumber, unsigned int
  interruptNumber) is a virtual function which is called each time an accessor for that interrupt is requested.
  This allows the lazy start of the interrupt handling threads, which are not started if no accessors are requested.
  The implementation must assure that the thread is only started once. In general, the NumericAddressedBackend does
  not take care of interrupt handling threads, except for calling this virtual function. Each backend implementation
  has to take care that treads are started, terminated and joined correctly.
  There is an empty default implementation of startInterruptHandlingThread() for backward compatibility
  (backends that don't support asynchronous data (yet) or that don't need a separate thread like the dummies).
- The interrupt handling threads call NumericAddressedBackend::dispatchInterrupt(unsigned int interruptControllerNumber,
   unsigned int  interruptNumber) each time the according interrupt arrives.
  
All other functionality for subscription, activation/deactivation and exception handling is already handled in the
NumericAddressedBackend base class.


*/

} // end of namespace ChimeraTK
