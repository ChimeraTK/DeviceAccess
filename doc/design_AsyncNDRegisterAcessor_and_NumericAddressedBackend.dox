namespace ChimeraTK {
/**
\page design_AsyncNDRegisterAccessor_NumericAddressed Design: AsyncNDRegisterAccessor

\section  design_AsyncNDRegisterAccessor The AsyncNDRegisterAccessor and the AsyncAccessorManager

The AsyncNDRegisterAccessor is the NDRegisterAccessor implementation for push-type data. It is a generic implementation
for all backends and contains the following components

- an NDRegisterAccessor<UserType>::Buffer which serves as a send buffer and contains the data value
  (2D vector of UserType), a VersionNumber and a DataValidity flag.
- a lockfree queue to transport the data from the send buffer
- functions to activate/deactivate the accessor, to push data and exceptions into the queue
- a synchronous accessor which is used for write operations (optional)

One AsyncAccessorManager is used per interrupt that can occur. The AsyncAccessor manager has three main functions:

- It serves as a factory for AsyncNDRegisterAccessors
- It contains a list of created asynchronous accessors and a subscribe/unsubcribe mechanism
- It provides functions to act on all asynchronous accessors

\subsection AsyncNDRegisterAccessor_details Design decisions and implementation details

- The data transport queue is of type UserType, so the potentialy expensive and slow operations (data readout,
  de-mutliplexing, data conversion) are happening only once, before the data is distributed to multiple subscribers.
- The additional send buffer is necessary because data has to be send through the queue in this container, and usually
  the data is not provided in this format.
  Even if the NDRegisterAccessor would provide the user buffer in this format it could not be used here, because it is
  used by the receiving side which is running in another thread.
- To unsubscribe, the NDRegisterAccessor is calling AsyncAccessorManager::unsibscribe() with its TransferElementId from
  the destructor.
  For the unsigbscribe mechanism to work, the AsyncAccessorManager can only hold a weak pointer.
  If it would hold a shared pointer, the destructor would never be called because this instance survives,
  even if the user code has deleted all copies of the AsyncNDRegisterAccessor.
- To manage the weak pointer and to have an entry object for the implementation, the helper class
  AsyncVariable has been introduced.\ref asyncAccessor_comment_AsyncVariable "(*)"
  It contain the weak pointer as a private variable and provides member functions to access the object behind
  the weak pointer.
  This ensures two points which otherwise would be left to the implementation, which would be error prone:
  - The weak pointer is locked before accessing the object.
  - There is a race condition that the locked object could have a nullptr if the shared pointer is currently being
     destructed while the lock is being acquired. This is checked as well.
- The void notification queue in the TransferElement base class is set up as a continuation of the data transport queue,
  such that the read operations of the notification queue trigger the filling of the user buffer.

\anchor asyncAccessor_comment_AsyncVariable (*) There is AsyncVariable as an untyped base class and AsyncVariableImpl,
  which is templated to a user type. Like this pointers to variables with different user types can be stored in one list.

\subsection AsyncNDRegisterAccessor_usage Interface for implementing backends

While the AsyncNDRegisterAccessor itself is complete and universal, the AsyncAccessorManager and
AsyncVariable have pure virtual functions which must be provided by the individual
backend implementations

- AsyncVariable::getNumberOfChannels(), AsyncVariable::getNumberOfSamples(), AsyncVariable::getUnit(),
  AsyncVariable::getDescription() and AsyncVariable::isWriteable() must be provided by derriving from AsyncVariable or
  AsyncVariableImpl. The information must directly be provided by the backend.
  The generating code cannot rely on the catalogue here (which might not even be filled yet when the accessor
  is being created).\ref asyncAccessor_comment_AsyncVariable "(*2)"
- The 'virtual function template' AsyncAccessorManager::createAsyncVariable() must provide an AsyncVariable
  implementation with the implemented accessor-describing functions from the previous bullet point, such that the
  accessor manager can create the AsyncNDRegisterAccessor.
  When createAsyncVariable() returns the AsyncVariable object, the weak pointer to the AsyncNDRegisterAccessor is not
  set yet. The reason is that the backend specific code should not have the subscription code, which is the same for
  all backends and would only be code duplication. And it is not sufficient to have the AsyncVariable, which only
  contains the weak pointer. The calling code also needs the shared pointer to the AsyncNDRegisterAccessor.
- AsyncAccessorManager::activate() needs to be implemented in the following way:
  -# Lock the mutex which protects the list of weak pointer, so no entries can be added or removed
  -# Generate a new version  number while holding the lock
  -# Write the intial value, the according data validity flag and the version number to _sendBuffer of each AsyncVariable
  -# Call activate() on all AsyncVariables
  Locking of the mutex, generation of the version number and calling activate() on each variable could be factored into
  the managern, with additional virtual functions that are called in between, but this means the container needs to be
  looped several times and the design gets more complicated and involved,
  and hence the implementation is left to the backend.

\anchor asyncAccessor_comment_AsyncVariable (*2) The reason to put this into the AsyncVariable is coming from the
  NumericAddressedBackend. It adds a synchronous accessor to the AsyncVariable which is used for reading and
  provides this information. The logic to generate this information is in the creation code of the synchronous
  accessor. Other backends might have similar advantages from having the functions the AsyncVariable, or at least
  they don't care much where the functions are implemented.


\section  design_async_NumericAddressedBackend Asynchronous accessors in the NumericAddressedBackend

As the NumericAddressedBackend base class already provides the creation of the synchronous NumericAddressedBackendRegisterAccessors, it also provides the subscription mechanism for the asynchronous accessors. The NumericAddressedBackend is based on a map file which allows to describe registers with interrupts. In the interface to the hardware, all interrupts are void. The map file then descibes which of the synchronous registers are read out and pushed when the according interrupt is triggered. This mechanism is implemented in the NumericAddressedBackend base class and the protocol implementing backends only have to notify the NumericAddressedInterruptDispatcher that the interrupt has happened.

\subsection  async_NumericAddressedBackend_interface Interface for backend implementations

The NumericAddressedInterruptDispatcher serves two purposes:
\li It serves as a subscription manager for the AsyncNDRegisterAccessor
\li It provides functions which act on all subsribers.

When the map file is read in, a NumericAddressedInterruptDispatcher is created for each interrupt.

The only function the backend implementor really has to deal with is NumericAddressedInterruptDispatcher::trigger(). All other functionaltiy for subscription, activation/deactivation and exception handling is already handled in the NumericAddressedBackend.

There is one NumericAddressedInterruptDispatcher per interrupt controller number and interrupt number, stored in the variable NumericAddressedBackend::_interruptDispatchers. The interrupt handling thread in the backend implementation will just call

<pre>
  _interruptDispatcher.at({interruptControllerNumber, interruptNumber})->trigger();
</pre>

Notice that you should access the map with at() and not through the [ ] operator, so you don't accidentally add empty dispatchers to the map.
The interrupt handler thread should have a "lazy start", which means that it should only be started once accessors to the particular interrupt have been requested. To achieve this, the backend should override NumericAddressedBackend::startInterruptHandlingThread(unsigned int interruptControllerNumber, unsigned int interruptNumber). This function is called each time an asynchronous accessor which is associated to that interrupt is created. The implementing code has to make sure that the thead is only started once. The thread in not terminated automatically. The backend has to take care to do this when the backend is closed and/or destructed.

Internally an object called NumericAddressedAsyncVariable (or to be more precie a shared pointer to the typed implementation NumericAddressedAsyncVariableImpl) is stored for each required accessor type. This contains one synchronous read accessor together with all its subscribers. Like this the hardware access to the devide and the possibly expensive postRead() action (de-mupltiplexing and numeric conversion) are only done once, before the data is pushed into the data transport queues of the subscribers.
There can be multiple NumericAddressedAsyncVariables for one register. For example one for raw access, one with data conversion and a thrid one for only the first 10 elements in a large 1D register. All this is happening automatically in the NumericAddressedBackend and the developer of the individual backend does not have to care about it.

\subsection design_async_map_file Asynchronous registers in the map file

<pre>
# name            nElements  address  nBytes  bar  width  bitInterpretation signed accessMode
APP.0.DATA_READY          0        0       0    0      0                  0      0 INTERRUPT1:5
APP.0.PUSH_DATA           4       12      16    1     32                  8      1 INTERRUPT2:3
</pre>

The map file has been extended by the access mode INTERRUPTx:y. Before, only RW and RO were allowed. x and y are the number of the interrupt controller and the interrupt number, respectively. Registers with access mode INTERRUPT will implicitly be treaded as read-only.

For interrupts it is possible to have void-type entries. The width of these "registers" is 0 bits. For consistency all other fields also have to be 0. They don't make sencse in this context and have to be 0 to avoid confusion.
*/

} // end of namespace ChimeraTK
