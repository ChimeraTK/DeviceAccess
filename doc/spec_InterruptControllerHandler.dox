// put the namespace around the doxygen block so we don't have to give it all the time in the code to get links
namespace ChimeraTK {
/**
\page spec_InterruptHandler Technical specification: InterruptHandler V0.1draft

> **NOTICE FOR FUTURE RELEASES: AVOID CHANGING THE NUMBERING!** The tests refer to the sections, incl. links and unlinked references from tests or other parts of the specification. These break, or even worse become wrong, when they are not changed consistenty!

## Introduction ##

This document describes the concept of interrupt handlers in backends, their implementation and their interface to firmware, i.e. their description in the map file.

### Context ###

The current implementation INTERRUPTc:i (with c being the interrupt controller number and i being the interrupt) is wrong on several levels.
* The highest level is always associated with a hardware interrupt. If there is one interrupt controller, this is correct. If there is no interrupt controller, it is already wrong. It currently is INTERRUPT0:i, but should be INTERRUPTi. (e.g. with interrupt controller INTERRUPT0:5 is on HW interrupt 0, while without it is on HW interrupt 5, which is inconsistent).
* Nested interrupts cannot be described at all.

This specification describes the hierarchical interrupt scheme that solves these issues.

## A. Definitions ##

- hwInterruptID is an integer which identifies the primary hardware interrupt
- qualifiedID is the ID including all the parent hierarcy. It can be evaluated on any level.
  Example: INTERRUPT2:3:4 on a nested interrupt controller
  - 2 is the qualifiedID of the parent interrupt controller (identical to the HW interrupt ID, see \ref interruptHandler_B1_1).
  - 2:3 is the qualified ID of the nested interrupt controller (identical to the interrupt generated by interrupt controller 2)
  - 2:3:4 is the qualified ID of the interrupt generated by controller 2:3
- INTERRUPTi[:j[:k[...]]] means any level of nesting

- The interrupt controller resides in firmware
- The InterruptControllerHandler is the software class that interacts with the according interrupt controller (resolve interrupt lane and perform handshake)
- Interrupt handler and interrupt handling are generic. It can be the handling of a HW interrupt lane or inside a controller.
- HW interrupt is used for the primary interrupt where no interrupt controller is involved that is handled by software (for instance Message Signaled PCIe Interrupts are considered as HW interrupt)

## B. Behavioural specification

- B1. Interrupts and interrupt controllers are identified with a numerical ID (unsigned integer)
  - \anchor interruptHandler_B1_1 B1.1 The controller ID is always identical to the parent interrput (e.g. controller 1 is behind hardware interrupt 1)
- B2. To identify interrupts resolved by a controller, their IDs are appended to the parent interrupt in a hierarchical way. This allows to nest interrupt controllers.
- B3. In string form (e.g. in the map file and this document), a colon ":" is used as hierarchy separator.
  - B3.1 Programmatic implementations can vary from this (e.g. in C++ the interrupt can be descibed as a list/vector of integers)
- B4. It is always possible to get an accessor for all interrupt hierarchy levels.
  - B4.1 An accessor with the name INTERRUPTk[:l[:m[...]]] can be acquired, even if there is no map file entry for it.
- B5. Backend implementations (NumericAddressedBackend)
  - B5.1 The backed is handling the primary hardware interrupts.
    - B5.1.1 The NumericAddressedBackend provides the pure virtual startInterruptHandlingThread(hwIntertruptID), which has to be implemented by the specific backends
    - B5.1.2 In case an interrupt is seen by the handling thread for a specific hwIntertruptID, the thread has to
      - B5.1.2.1 call the backends dispatchInterrupt() with the hwIntertruptID as argument (FIXME (*1))
      - B5.1.2.2 if the there is an InterruptControllerHandler associated with the interrupt which fired, it calls its trigger() function
    
  - B5.2 The backend provides a function dispatchInterrupt(qualifiedID)
    - B5.2.1 Already implemented in the NumericAddressedBackend base class
  - B5.3 Once startInterruptHandlingThread(hwIntertruptID) has been called, the backed must accept calls to dispatchInterrupt() with all qualifiedID associated with that hwInterruptID, even if no accessor has been created a for it. In this case the call just does nothing.
    - B5.3.1 Already implemented in the NumericAddressedBackend base class
- B6. InterruptConrollerHandlers
     - B6.1 A C++ InterruptControllerHandler base class defines the interface to the (numerically addressed) backend and parent/nested interrupt controller handlers, such that
         - B6.1.1 different InterruptControllerHandler implementations can be used by one backed
         - B6.1.2 an InterruptControllerImplementation can be used by multiple backends
         - B6.1.3 different kinds of InterruptControllerImplementations can be nested
     - B6.2 Each InterruptControllerHandler
         - B6.2.1 knows its numeric ID (FIXME or qualified ID?)
         - B6.2.2 knows its parent (if any) (FIXME needed only do calculate qualified ID from numeric ID?)
         - B6.2.3 knows nested InterruptControllerHandlers
         - B6.2.4 has a trigger() function which
           - B6.2.4.1 does the handshake with the interrupt contoller to determine which interrupt has fired
           - B6.2.4.2 calls the backends dispatchInterrupt() function with the qualified ID of the interrupt that has fired (FIXME (*1))
           - B6.2.4.3 if there is a nested InterruptControllerHandler associated with the interrupt that has fired, it calls its trigger() function
         

FIXME (*1)
B.5.1.2.1 and B6.2.4.2 implement B4.1. In this case the NumericAddressedBackends  dispatchInterrupt() only triggers the interrupts for the EXACT qualified ID.
An alternative implementation would be:

- B5.1.2 In case an interrupt is seen by the handling thread for a specific hwIntertruptID, the thread has to 
      - B5.1.2.1* call the backends dispatchInterrupt() with the hwIntertruptID as argument <b> if there is no  InterruptControllerHandler associated with the interrupt which fired </b>
      - B5.1.2.2 if  there is an InterruptControllerHandler associated with the interrupt which fired, it calls its trigger() function

- B6.2.4 has a trigger() function which
      - ...
      - B6.2.4.2 calls the backends dispatchInterrupt() function with the qualified ID of the interrupt that has fired <b> if there is no  InterruptControllerHandler associated with the interrupt which fired </b>
      - B6.2.4.3 if there is a nested InterruptControllerHandler associated with the interrupt that has fired, it calls its trigger() function

- <b> B5.2.2 dispatchInterrupt(qualifiedID) sends to accessors for all levels of the qualifiedID </b>

There is a behavioural difference for both implementations in case the interrupt controller reports that more than one interrupt has fired. If for instance interrupt controller 2 would see interrupts 3 and 4, in the first case the accessors for INTERRUPT2 would see data only once, becasue there was only one HW interrupt, in the second case the  accessors for INTERRUPT2 would see data twice, because two interrupts in there have fired. Both scenarios can have valid use cases and we have to specify which behaviour we want.
END OF FIXME (*1)

FIXME (*2)
What is the behaviour in case of missed interrupts?
*/
} // end of namespace ChimeraTK
